<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Yomiru - Anime Recommendations</title>
  <link rel="stylesheet" href="newCss.css">
  <link rel="stylesheet" href="recommendations.css">
  <link rel="stylesheet" href="recommendations.css">
<link rel="icon" href="images/logo.png" type="image/png">
</head>
<body style="min-height:100vh; margin:0; display:flex; flex-direction:column;" style="min-height:100vh; margin:0; display:flex; flex-direction:column;">
  <header>
    <div class="logo"><a href="index.html"><img src="images/Website_logo_new.png" alt="Website logo"></a></div>
    <nav class="navbar">
      <a href="Ghibli.html">Ghibli</a>
      <a href="tracemoe.html">Tracemoe</a>
      <a href="recommendations.html">Recommendations</a>
      <a href="chatbot.html">Yomiru bot</a>
      <a href="about.html">About</a>
      
      <div class="search-button">
        <button class="search-btn" onclick="window.location.href='search.html'">
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="11" cy="11" r="8"></circle>
            <path d="m21 21-4.35-4.35"></path>
          </svg>
        </button>
      </div>
    </nav>
  </header>
<body>
  <section class="anime-recommendation-wrapper">
    <div class="anime-card-container">
      <div id="anime-cards">
        <!-- Cards will be dynamically inserted here -->
      </div>
      <div class="anime-info-box">
        <div id="anime-info">
          <strong id="anime-title">Pokemon</strong>
          <p id="anime-synopsis">Two teens switch bodies mysteriously.</p>
        </div>
      </div>
      <div class="tinder-buttons">
        <button class="tinder-btn cross" id="cross-btn" title="Nope">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M18 6L6 18" stroke="white" stroke-width="3" stroke-linecap="round"/>
            <path d="M6 6L18 18" stroke="white" stroke-width="3" stroke-linecap="round"/>
          </svg>
        </button>
        <button class="tinder-btn check" id="check-btn" title="Like & Add to Watchlist">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M20 6L9 17L4 12" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </button>
      </div>
      
      <div class="download-section">
        <button class="download-btn" id="download-docs-btn">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            <polyline points="7,10 12,15 17,10" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            <line x1="12" y1="15" x2="12" y2="3" stroke="white" stroke-width="2" stroke-linecap="round"/>
          </svg>
          <span>Download Watchlist (<span id="docs-count">0</span>)</span>
        </button>
      </div>
    </div>
  </section>

  <script>
    // Detect environment and set API base URL accordingly
    const API_BASE = window.location.hostname === 'localhost' 
      ? "http://localhost:3000" 
      : "https://final-project-10-streams.onrender.com";
    
    // Store user likes for recommendation algorithm
    let userLikes = [];
    let similarAnimeList = [];
    let trendingAnimeList = [];
    let displayQueue = [];
    let current = 0;
    
    // Track shown anime to prevent repeats
    let shownAnimeIds = new Set();
    let currentOffset = 0; // For pagination when fetching more trending anime
    
    // Document/Watchlist functionality
    let watchlistAnime = [];
    let watchlistIds = new Set();
    
    const cardsContainer = document.getElementById('anime-cards');
    let isLoading = true;
    
    // Demo data for trending anime (fallback if API fails)
    function getDemoTrendingAnime() {
      const demoAnime = [
        { 
          title: 'One Piece', 
          synopsis: 'Monkey D. Luffy sets sail with his crew in search of the legendary treasure known as One Piece, aiming to become the King of the Pirates.',
          main_picture: { large: 'images/onepiece.jpeg' },
          id: 1
        },
        { 
          title: 'Naruto', 
          synopsis: 'Naruto Uzumaki, a mischievous adolescent ninja, struggles as he searches for recognition and dreams of becoming the Hokage.',
          main_picture: { large: 'images/naruto.jpeg' },
          id: 2
        },
        { 
          title: 'Bleach', 
          synopsis: 'Ichigo Kurosaki gains the powers of a Soul Reaper and dedicates his life to protecting the innocent from evil spirits.',
          main_picture: { large: 'images/bleach.jpg' },
          id: 3
        },
        { 
          title: 'Pokemon', 
          synopsis: 'Ash Ketchum aims to become a Pokemon Master by catching and training Pokemon, traveling across various regions.',
          main_picture: { large: 'images/pokemon.jpg' },
          id: 4
        }
      ];
      
      // Filter out already shown demo anime
      return demoAnime.filter(anime => !shownAnimeIds.has(anime.id));
    }
    
    // Demo data for similar anime (fallback if API fails)
    function getDemoSimilarAnime() {
      const demoAnime = [
        { 
          title: 'Dragon Ball Z', 
          synopsis: 'Goku and his friends defend Earth from various villains threatening the planet and universe.',
          main_picture: { large: 'images/dbz.jpg' },
          id: 5
        },
        { 
          title: 'Hunter x Hunter', 
          synopsis: 'Gon Freecss takes the Hunter Exam to find his father, who is a legendary Hunter.',
          main_picture: { large: 'images/gon.jpg' },
          id: 6
        }
      ];
      
      // Filter out already shown demo anime
      return demoAnime.filter(anime => !shownAnimeIds.has(anime.id));
    }
    
    // Show loading indicator
    function showLoading() {
      cardsContainer.innerHTML = ''; // Clear previous content
      const loadingDiv = document.createElement('div');
      loadingDiv.className = 'loading-indicator';
      loadingDiv.id = 'loading-indicator';
      
      const spinner = document.createElement('div');
      spinner.className = 'loading-spinner';
      
      const text = document.createElement('p');
      text.textContent = 'Finding anime recommendations...';
      
      loadingDiv.appendChild(spinner);
      loadingDiv.appendChild(text);
      
      cardsContainer.appendChild(loadingDiv);
      // Also update the info box
      document.getElementById('anime-title').textContent = 'Loading...';
      document.getElementById('anime-synopsis').textContent = 'Please wait while we fetch personalized recommendations.';
    }
    
    // Hide loading indicator
    function hideLoading() {
      const loadingDiv = document.getElementById('loading-indicator');
      if (loadingDiv) {
        loadingDiv.remove();
      }
      isLoading = false;
    }
    
    // Fetch trending anime from MAL API
    async function fetchTrendingAnime(limit = 20) {
      try {
        const url = `${API_BASE}/mal/trending?limit=${limit}&offset=${currentOffset}`;
        console.log(`üåê Fetching trending anime from: ${url}`);
        
        const response = await fetch(url, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
          },
        });
        
        console.log('üì° Response status:', response.status, response.statusText);
        
        if (!response.ok) {
          console.error(`‚ùå API request failed with status: ${response.status}`);
          const errorText = await response.text();
          console.error('Error response:', errorText);
          return getDemoTrendingAnime();
        }
        
        const data = await response.json();
        console.log('üì¶ Raw API response:', data);
        
        if (data && data.anime && Array.isArray(data.anime) && data.anime.length > 0) {
          // Filter out already shown anime AND anime already in our lists
          const existingIds = new Set([
            ...Array.from(shownAnimeIds),
            ...displayQueue.map(a => a.id),
            ...trendingAnimeList.map(a => a.id),
            ...similarAnimeList.map(a => a.id)
          ]);
          
          const newAnime = data.anime.filter(anime => !existingIds.has(anime.id));
          console.log(`‚úÖ Filtered ${data.anime.length} anime down to ${newAnime.length} truly new anime`);
          console.log('Sample new anime:', newAnime[0]);
          
          // Update offset for next fetch
          currentOffset += limit;
          console.log('Updated offset to:', currentOffset);
          
          return shuffleArray(newAnime);
        } else {
          console.warn('‚ö†Ô∏è API returned empty or invalid data structure');
          console.log('Data structure:', typeof data, Object.keys(data || {}));
          return getDemoTrendingAnime();
        }
      } catch (error) {
        console.error('‚ùå Network error fetching trending anime:', error);
        console.error('Error details:', error.message, error.stack);
        return getDemoTrendingAnime();
      }
    }
    
    // Fetch more anime when running low
    async function fetchMoreAnime() {
      console.log('Fetching more anime to prevent repeats...');
      const moreTrending = await fetchTrendingAnime(30); // Fetch more at once
      
      if (moreTrending.length > 0) {
        trendingAnimeList.push(...moreTrending);
        console.log(`Added ${moreTrending.length} more trending anime. Total: ${trendingAnimeList.length}`);
      }
      
      // If we have user likes, also fetch more similar anime
      if (userLikes.length > 0) {
        const moreSimilar = await fetchSimilarAnime();
        if (moreSimilar.length > 0) {
          // Filter out duplicates from similar anime list too
          const uniqueSimilar = moreSimilar.filter(anime => 
            !similarAnimeList.some(existing => existing.id === anime.id) &&
            !shownAnimeIds.has(anime.id)
          );
          similarAnimeList.push(...uniqueSimilar);
          console.log(`Added ${uniqueSimilar.length} more similar anime. Total: ${similarAnimeList.length}`);
        }
      }
    }
    
    // Fetch similar anime based on user likes
    async function fetchSimilarAnime() {
      if (userLikes.length === 0) {
        console.log('No user likes yet, skipping similar anime fetch');
        return [];
      }
      
      try {
        console.log('Fetching similar anime based on user likes:', userLikes.map(a => a.title));
        
        // Use the most recent liked anime for recommendations
        const recentLike = userLikes[userLikes.length - 1];
        const response = await fetch(`${API_BASE}/mal/similar/${recentLike.id}?limit=15`, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
          },
        });
        
        if (!response.ok) {
          console.warn(`Similar anime API request failed with status: ${response.status}`);
          return getDemoSimilarAnime();
        }
        
        const data = await response.json();
        console.log('Similar anime API response:', data);
        
        if (data && data.similar && data.similar.length > 0) {
          // Filter out already shown anime and liked anime
          const likedIds = new Set(userLikes.map(anime => anime.id));
          const newSimilar = data.similar.filter(anime => 
            !shownAnimeIds.has(anime.id) && 
            !likedIds.has(anime.id)
          );
          console.log(`Filtered ${data.similar.length} similar anime down to ${newSimilar.length} new anime`);
          
          return shuffleArray(newSimilar);
        } else {
          console.warn('Similar anime API returned empty or invalid data');
          return getDemoSimilarAnime();
        }
      } catch (error) {
        console.error('Error fetching similar anime:', error);
        return getDemoSimilarAnime();
      }
    }
    
    // Create display queue alternating between similar and trending
    function createDisplayQueue(similarList, trendingList) {
      console.log('Creating display queue with similar:', similarList.length, 'trending:', trendingList.length);
      
      // Filter out already shown anime from both lists
      const availableSimilar = similarList.filter(anime => !shownAnimeIds.has(anime.id));
      const availableTrending = trendingList.filter(anime => !shownAnimeIds.has(anime.id));
      
      console.log('Available after filtering - similar:', availableSimilar.length, 'trending:', availableTrending.length);
      
      const queue = [];
      const maxItems = 10; // Create a queue of next 10 anime to show
      
      // If we have similar anime, alternate. Otherwise, just use trending
      if (availableSimilar.length > 0) {
        let similarIndex = 0;
        let trendingIndex = 0;
        
        for (let i = 0; i < maxItems && (similarIndex < availableSimilar.length || trendingIndex < availableTrending.length); i++) {
          if (i % 2 === 0 && similarIndex < availableSimilar.length) {
            // Add similar anime (even indices)
            queue.push({ ...availableSimilar[similarIndex], source: 'similar' });
            similarIndex++;
          } else if (trendingIndex < availableTrending.length) {
            // Add trending anime (odd indices or when no more similar)
            queue.push({ ...availableTrending[trendingIndex], source: 'trending' });
            trendingIndex++;
          } else if (similarIndex < availableSimilar.length) {
            // Fallback to similar if no more trending
            queue.push({ ...availableSimilar[similarIndex], source: 'similar' });
            similarIndex++;
          }
        }
      } else {
        // No similar anime, just use trending
        for (let i = 0; i < Math.min(maxItems, availableTrending.length); i++) {
          queue.push({ ...availableTrending[i], source: 'trending' });
        }
      }
      
      console.log('Created queue with', queue.length, 'items');
      return queue;
    }
    
    // Fisher-Yates shuffle algorithm
    function shuffleArray(array) {
      const newArray = [...array];
      for (let i = newArray.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
      }
      return newArray;
    }
    
    // Create and add all cards initially
    function createCards() {
      console.log('üèóÔ∏è Creating cards...');
      cardsContainer.innerHTML = ''; // Clear existing cards
      
      console.log('Creating cards with displayQueue:', displayQueue);
      
      if (!displayQueue || displayQueue.length === 0) {
        console.error('Display queue is empty, using demo data');
        displayQueue = getDemoTrendingAnime().map(anime => ({ ...anime, source: 'trending' }));
      }
      
      // Create cards for all anime in queue
      displayQueue.forEach((anime, index) => {
        createSingleCard(anime, index);
      });
      
      // Show only the current card
      showCurrentCard();
      
      // Ensure buttons are always visible
      document.querySelector('.tinder-buttons').style.display = 'flex';
      
      console.log(`‚úÖ Created ${displayQueue.length} cards`);
    }
    
    // Add new cards to the existing deck (WITHOUT clearing existing cards)
    function addNewCards(newAnime, startIndex) {
      console.log('üÜï Adding', newAnime.length, 'new cards starting at index', startIndex);
      
      newAnime.forEach((anime, index) => {
        const cardIndex = startIndex + index;
        createSingleCard(anime, cardIndex);
        console.log(`‚ûï Added card ${cardIndex}: ${anime.title}`);
      });
      
      console.log(`‚úÖ Added ${newAnime.length} new cards to existing deck`);
    }
    
    // Create a single card
    function createSingleCard(anime, index) {
      const card = document.createElement('div');
      card.className = 'anime-card';
      card.id = `card-${index}`;
      card.style.zIndex = 100 - index;
      
      // Hide all cards except current and next few
      if (index < current) {
        card.style.display = 'none';
      } else if (index === current) {
        card.style.opacity = 1;
        card.style.transform = 'scale(1) translateY(0)';
      } else {
        card.style.opacity = 0.8;
        card.style.transform = `scale(${1 - (index - current) * 0.05}) translateY(${(index - current) * 10}px)`;
      }
      
      const carousel = document.createElement('div');
      carousel.className = 'anime-card-carousel';
      
      const sourceBadge = document.createElement('div');
      sourceBadge.className = 'recommendation-source';
      sourceBadge.textContent = anime.source === 'similar' ? 'Based on your likes' : 'Trending';
      carousel.appendChild(sourceBadge);
      
      const imagesContainer = document.createElement('div');
      imagesContainer.className = 'anime-card-images';
      imagesContainer.id = `images-${index}`;
      
      const images = getAnimeImages(anime.title, anime.main_picture);
      
      images.forEach((imgSrc, imgIndex) => {
        const img = document.createElement('img');
        img.className = 'anime-card-image';
        img.src = imgSrc;
        img.alt = `${anime.title} image ${imgIndex + 1}`;
        
        console.log(`üèóÔ∏è Creating img element for ${anime.title}:`);
        console.log(`   Index: ${imgIndex}`);
        console.log(`   URL: ${imgSrc}`);
        console.log(`   Alt: ${img.alt}`);
        
        img.onerror = function() { 
          console.error('‚ùå Image failed to load:', imgSrc, 'for anime:', anime.title);
          this.src = 'images/logo.png'; // Use existing logo as fallback
          console.log('üîÑ Switched to fallback image: images/logo.png');
        };
        
        img.onload = function() {
          console.log('‚úÖ Image loaded successfully:', imgSrc, 'for anime:', anime.title);
        };
        
        imagesContainer.appendChild(img);
      });
      
      const navContainer = document.createElement('div');
      navContainer.className = 'anime-card-nav';
      
      const prevBtn = document.createElement('button');
      prevBtn.className = 'nav-btn prev';
      prevBtn.innerHTML = '&#10094;';
      prevBtn.onclick = (e) => { e.stopPropagation(); navigateImages(index, 'prev'); };
      
      const nextBtn = document.createElement('button');
      nextBtn.className = 'nav-btn next';
      nextBtn.innerHTML = '&#10095;';
      nextBtn.onclick = (e) => { e.stopPropagation(); navigateImages(index, 'next'); };
      
      navContainer.appendChild(prevBtn);
      navContainer.appendChild(nextBtn);
      
      const indicatorContainer = document.createElement('div');
      indicatorContainer.className = 'image-indicator';
      
      images.forEach((_, dotIndex) => {
        const dot = document.createElement('div');
        dot.className = `indicator-dot ${dotIndex === 0 ? 'active' : ''}`;
        indicatorContainer.appendChild(dot);
      });
      
      carousel.appendChild(imagesContainer);
      carousel.appendChild(navContainer);
      carousel.appendChild(indicatorContainer);
      
      card.appendChild(carousel);
      cardsContainer.appendChild(card);
      card.dataset.currentImage = 0;
    }
    
    // Show the current card and position next cards
    function showCurrentCard() {
      console.log(`üé¥ Showing current card: ${current}/${displayQueue.length}`);
      
      displayQueue.forEach((anime, index) => {
        const card = document.getElementById(`card-${index}`);
        if (!card) {
          console.warn(`‚ö†Ô∏è Card ${index} not found`);
          return;
        }
        
        if (index < current) {
          // Hide previous cards
          card.style.display = 'none';
        } else if (index === current) {
          // Show current card prominently
          card.style.display = 'block';
          card.style.opacity = 1;
          card.style.transform = 'scale(1) translateY(0)';
          card.style.zIndex = 100;
          console.log(`‚ú® Current card (${index}): ${anime.title}`);
        } else if (index <= current + 2) {
          // Show next 2 cards in stack
          card.style.display = 'block';
          card.style.opacity = 0.8;
          card.style.transform = `scale(${1 - (index - current) * 0.05}) translateY(${(index - current) * 10}px)`;
          card.style.zIndex = 100 - (index - current);
        } else {
          // Hide cards that are too far ahead
          card.style.display = 'none';
        }
      });
    }
    
    function getAnimeImages(title, mainPicture) {
      console.log('üñºÔ∏è =========================');
      console.log('Getting images for:', title);
      console.log('mainPicture object:', mainPicture);
      
      // Prioritize remote images from MAL API
      const remoteImages = [];
      if (mainPicture) {
        if (mainPicture.large) {
          console.log('üì∏ Found large image:', mainPicture.large);
          remoteImages.push(mainPicture.large);
        }
        if (mainPicture.medium) {
          console.log('üì∏ Found medium image:', mainPicture.medium);
          remoteImages.push(mainPicture.medium);
        }
      } else {
        console.log('‚ö†Ô∏è No mainPicture object provided');
      }
      
      // Only use local images as fallback if no remote images available
      const imageMap = {
        'Naruto': ['images/naruto.jpeg', 'images/naruto02.jpg'],
        'Bleach': ['images/bleach.jpg'],
        'One Piece': ['images/onepiece.jpeg'],
        'Pokemon': ['images/pokemon.jpg'],
        'Dragon Ball Z': ['images/dbz.jpg'],
        'Hunter x Hunter': ['images/logo.png'], // Use logo as fallback for Hunter x Hunter
      };
      
      // If we have remote images, use only those. Otherwise, use local as fallback
      let finalImages;
      if (remoteImages.length > 0) {
        finalImages = remoteImages;
        console.log('‚úÖ Using remote MAL images:', finalImages);
      } else {
        const localImages = imageMap[title] || [];
        finalImages = localImages.length > 0 ? localImages : ['images/logo.png'];
        console.log('‚ùå No remote images, using local fallback:', finalImages);
      }
      
      console.log('üéØ FINAL DECISION for', title, ':', finalImages);
      console.log('üñºÔ∏è =========================');
      return finalImages;
    }
    
    function navigateImages(cardIndex, direction) {
      const card = document.getElementById(`card-${cardIndex}`);
      const imagesContainer = document.getElementById(`images-${cardIndex}`);
      if (!card || !imagesContainer) return;
      
      const images = imagesContainer.querySelectorAll('.anime-card-image');
      const totalImages = images.length;
      let currentImageIndex = parseInt(card.dataset.currentImage, 10);
      
      if (direction === 'next') currentImageIndex = (currentImageIndex + 1) % totalImages;
      else currentImageIndex = (currentImageIndex - 1 + totalImages) % totalImages;
      
      imagesContainer.style.transform = `translateX(-${currentImageIndex * 100}%)`;
      
      const indicators = card.querySelectorAll('.indicator-dot');
      indicators.forEach((dot, i) => dot.classList.toggle('active', i === currentImageIndex));
      
      card.dataset.currentImage = currentImageIndex;
    }
    
    // Update anime information display
    function updateInfo(index) {
      if (!displayQueue[index]) {
        console.error('No anime at index:', index);
        return;
      }
      
      const anime = displayQueue[index];
      console.log('Updating info for:', anime.title);
      
      document.getElementById('anime-title').textContent = anime.title;
      document.getElementById('anime-synopsis').textContent = anime.synopsis || 'Loading synopsis...';
      
      // Fetch detailed synopsis if not available
      if (!anime.synopsis) {
        getAnimeInfo(anime.title).then(synopsis => {
          anime.synopsis = synopsis;
          if (index === current) {
            document.getElementById('anime-synopsis').textContent = synopsis;
          }
        });
      }
    }

    // Debug function to check current state
    function debugCurrentState() {
      console.log('üîç DEBUG STATE:');
      console.log(`   Current index: ${current}`);
      console.log(`   Queue length: ${displayQueue.length}`);
      console.log(`   Current anime: ${displayQueue[current]?.title || 'NONE'}`);
      console.log(`   Next anime: ${displayQueue[current + 1]?.title || 'NONE'}`);
      
      // Check if cards exist in DOM
      const currentCard = document.getElementById(`card-${current}`);
      const nextCard = document.getElementById(`card-${current + 1}`);
      console.log(`   Current card exists: ${!!currentCard}`);
      console.log(`   Next card exists: ${!!nextCard}`);
      
      if (currentCard) {
        console.log(`   Current card display: ${currentCard.style.display}`);
        console.log(`   Current card opacity: ${currentCard.style.opacity}`);
      }
      
      if (nextCard) {
        console.log(`   Next card display: ${nextCard.style.display}`);
        console.log(`   Next card opacity: ${nextCard.style.opacity}`);
      }
    }

    // Handle card swiping
    async function swipeCard(direction) {
      console.log(`üéØ Swiping ${direction} on anime:`, displayQueue[current]?.title);
      
      if (!displayQueue[current]) {
        console.error('‚ùå No current anime to swipe');
        debugCurrentState();
        return;
      }
      
      const currentAnime = displayQueue[current];
      
      // Mark this anime as shown to prevent repeats
      shownAnimeIds.add(currentAnime.id);
      console.log(`‚úÖ Added anime ID ${currentAnime.id} to shown list. Total shown: ${shownAnimeIds.size}`);
      
      // If user liked the anime, add to likes AND add to watchlist
      if (direction === 'right') {
        userLikes.push(currentAnime);
        console.log('üíñ Added to likes:', currentAnime.title);
        console.log('Total likes:', userLikes.length);
        
        // Automatically add to watchlist when user likes
        addToWatchlist(currentAnime, false); // false = don't show notification since we're swiping
        
        // Refresh recommendations every 2 likes to get new similar anime
        if (userLikes.length % 2 === 0) {
          console.log('üîÑ Refreshing recommendations after', userLikes.length, 'likes');
          
          // Add swipe animation first
          let currentCard = document.getElementById(`card-${current}`);
          if (!currentCard) {
            console.warn(`‚ö†Ô∏è Current card ${current} missing, recreating...`);
            createSingleCard(currentAnime, current);
            currentCard = document.getElementById(`card-${current}`);
          }
          
          if (currentCard) {
            currentCard.classList.add('swipe-right');
            
            setTimeout(async () => {
              currentCard.style.display = 'none';
              
              // Now refresh recommendations (this will reset current to 0 and create new queue)
              await refreshRecommendations();
              
              console.log('üéØ After refresh - current:', current, 'showing:', displayQueue[current]?.title);
            }, 300);
          }
          
          return; // Exit early as refreshRecommendations handles everything
        }
      }
      
      // Get the current card (create if missing)
      let currentCard = document.getElementById(`card-${current}`);
      if (!currentCard) {
        console.warn(`‚ö†Ô∏è Current card ${current} missing, recreating...`);
        createSingleCard(currentAnime, current);
        currentCard = document.getElementById(`card-${current}`);
      }
      
      if (currentCard) {
        currentCard.classList.add(direction === 'right' ? 'swipe-right' : 'swipe-left');
        
        setTimeout(() => {
          // Hide the current card
          currentCard.style.display = 'none';
          
          // Move to next anime
          current++;
          console.log(`üì± Advanced to anime ${current}/${displayQueue.length}`);
          
          // Debug current state
          debugCurrentState();
          
          // Check if we have a next anime to show
          if (current < displayQueue.length) {
            // Get or create the next card
            let nextCard = document.getElementById(`card-${current}`);
            if (!nextCard) {
              console.warn(`‚ö†Ô∏è Next card ${current} missing, creating...`);
              createSingleCard(displayQueue[current], current);
              nextCard = document.getElementById(`card-${current}`);
            }
            
            if (nextCard) {
              // Show the next card
              nextCard.style.display = 'block';
              nextCard.style.opacity = 1;
              nextCard.style.transform = 'scale(1) translateY(0)';
              nextCard.style.zIndex = 100;
              
              // Update card positions for stacking effect
              showCurrentCard();
              
              // Update anime info
              updateInfo(current);
              console.log(`‚úÖ Now showing: ${displayQueue[current]?.title}`);
            } else {
              console.error('‚ùå Failed to create next card');
            }
          } else {
            console.log('üì• Reached end of queue, fetching more anime...');
            fetchMoreAnime().then(() => {
              // After fetching more, ensure we have cards
              if (current < displayQueue.length) {
                let nextCard = document.getElementById(`card-${current}`);
                if (!nextCard) {
                  createSingleCard(displayQueue[current], current);
                }
                showCurrentCard();
                updateInfo(current);
              }
            });
          }
          
          // Check if we need more anime (when we have 3 or fewer left)
          if (displayQueue.length - current <= 3) {
            console.log('üîÑ Running low on anime, fetching more...');
            fetchMoreAnime().then(() => {
              // Add new anime to the existing queue
              const newQueue = createDisplayQueue(similarAnimeList, trendingAnimeList);
              const uniqueNewAnime = newQueue.filter(anime => 
                !displayQueue.some(existing => existing.id === anime.id) &&
                !shownAnimeIds.has(anime.id) // Prevent repeats
              );
              
              if (uniqueNewAnime.length > 0) {
                const startIndex = displayQueue.length;
                displayQueue.push(...uniqueNewAnime);
                addNewCards(uniqueNewAnime, startIndex);
                console.log(`‚úÖ Added ${uniqueNewAnime.length} more anime to queue`);
              }
            });
          }
        }, 300);
      } else {
        console.error('‚ùå Could not create or find current card');
        debugCurrentState();
      }
    }
    
    async function refreshRecommendations() {
      console.log('üîÑ Refreshing recommendations...');
      showLoading();
      
      try {
        // Fetch new similar anime based on user likes
        const newSimilarAnime = await fetchSimilarAnime();
        console.log('üì• Fetched', newSimilarAnime.length, 'new similar anime');
        
        // Add unique similar anime to the list
        const uniqueSimilar = newSimilarAnime.filter(anime => 
          !similarAnimeList.some(existing => existing.id === anime.id) &&
          !shownAnimeIds.has(anime.id)
        );
        similarAnimeList.push(...uniqueSimilar);
        
        // Create completely new display queue starting fresh
        const newQueue = createDisplayQueue(similarAnimeList, trendingAnimeList);
        console.log('üîÑ Created fresh display queue with', newQueue.length, 'items');
        
        // Filter out already shown anime from the new queue
        const freshQueue = newQueue.filter(anime => !shownAnimeIds.has(anime.id));
        console.log('‚úÖ Filtered to', freshQueue.length, 'unseen anime');
        
        if (freshQueue.length > 0) {
          // Replace the display queue with fresh content
          displayQueue = freshQueue;
          current = 0; // Reset to start of new queue
          
          console.log('üéØ Resetting to fresh queue, now showing:', displayQueue[current]?.title);
          
          // Recreate all cards with the fresh queue
          createCards();
          updateInfo(current);
          
          console.log('‚úÖ Refreshed with new recommendations');
        } else {
          console.warn('‚ö†Ô∏è No new unseen anime in refresh, continuing with current queue');
        }
        
      } catch (error) {
        console.error('‚ùå Error refreshing recommendations:', error);
      } finally {
        hideLoading();
      }
    }
    
    async function getAnimeInfo(title) {
      try {
        const response = await fetch(`${API_BASE}/mal/anime-info?title=${encodeURIComponent(title)}`);
        if (!response.ok) return "Synopsis not available.";
        const data = await response.json();
        const anime = data.data?.[0]?.node;
        // Prepend title to synopsis if not already there
        let synopsis = anime?.synopsis || "No synopsis available.";
        if (!synopsis.toLowerCase().includes(title.toLowerCase())) {
            synopsis = `${title}: ${synopsis}`;
        }
        return synopsis;
      } catch (error) {
        console.error(`Error fetching synopsis for ${title}:`, error);
        return "Error loading synopsis.";
      }
    }
    
    // Test backend connectivity
    async function testBackendConnectivity() {
      console.log('üîç Testing backend connectivity...');
      try {
        const response = await fetch(`${API_BASE}/mal/trending?limit=1`, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
          },
        });
        
        console.log('üîó Backend connectivity test:', response.status, response.statusText);
        
        if (response.ok) {
          const data = await response.json();
          console.log('‚úÖ Backend is reachable. Sample data:', data);
          return true;
        } else {
          console.error('‚ùå Backend returned error:', response.status);
          return false;
        }
      } catch (error) {
        console.error('‚ùå Cannot reach backend:', error.message);
        console.error('This might be a CORS issue or the backend is not running');
        return false;
      }
    }

    async function initializeRecommendations() {
      console.log('=== INITIALIZING RECOMMENDATIONS ===');
      
      // Test backend connectivity first
      const backendReachable = await testBackendConnectivity();
      if (!backendReachable) {
        console.warn('‚ö†Ô∏è Backend not reachable, using demo data only');
        displayQueue = getDemoTrendingAnime().map(anime => ({ ...anime, source: 'trending' }));
        createCards();
        updateInfo(current);
        return;
      }
      
      showLoading();
      
      try {
        // Try to fetch from API first
        console.log('Fetching trending anime from API...');
        trendingAnimeList = await fetchTrendingAnime();
        console.log('‚úÖ Fetched trending anime:', trendingAnimeList.length, 'items');
        console.log('First anime:', trendingAnimeList[0]);
        
        if (trendingAnimeList.length === 0) {
          console.warn('‚ö†Ô∏è No trending anime received from API');
          trendingAnimeList = getDemoTrendingAnime();
          console.log('Using demo data:', trendingAnimeList.length, 'items');
        }
        
        console.log('Creating display queue...');
        displayQueue = createDisplayQueue([], trendingAnimeList);
        console.log('‚úÖ Created display queue:', displayQueue.length, 'items');
        console.log('First queue item:', displayQueue[0]);
        
        if (displayQueue.length > 0) {
          console.log('Creating cards...');
          createCards();
          console.log('Updating info for current anime...');
          updateInfo(current);
          console.log('‚úÖ Successfully initialized with data');
        } else {
          console.error('‚ùå Display queue is empty, using demo data');
          displayQueue = getDemoTrendingAnime().map(anime => ({ ...anime, source: 'trending' }));
          console.log('Demo fallback queue:', displayQueue);
          createCards();
          updateInfo(current);
        }
      } catch (error) {
        console.error('‚ùå Error initializing recommendations:', error);
        console.log('Using demo data as final fallback');
        displayQueue = getDemoTrendingAnime().map(anime => ({ ...anime, source: 'trending' }));
        createCards();
        updateInfo(current);
      } finally {
        hideLoading();
        console.log('=== INITIALIZATION COMPLETE ===');
      }
    }
    
    // Document/Watchlist functions
    function showNotification(message, type = 'success') {
      const notification = document.createElement('div');
      notification.className = `notification ${type}`;
      notification.textContent = message;
      document.body.appendChild(notification);
      
      // Show notification
      setTimeout(() => notification.classList.add('show'), 100);
      
      // Hide notification after 3 seconds
      setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => document.body.removeChild(notification), 300);
      }, 3000);
    }
    
    function addToWatchlist(anime = null, showNotif = true) {
      const targetAnime = anime || displayQueue[current];
      if (!targetAnime) {
        if (showNotif) showNotification('No anime selected!', 'error');
        return;
      }
      
      // Check if already in watchlist
      if (watchlistIds.has(targetAnime.id)) {
        if (showNotif) showNotification(`${targetAnime.title} is already in your watchlist!`, 'error');
        return;
      }
      
      // Add to watchlist
      watchlistAnime.push({
        id: targetAnime.id,
        title: targetAnime.title,
        synopsis: targetAnime.synopsis || 'No synopsis available.',
        source: targetAnime.source,
        addedDate: new Date().toLocaleDateString(),
        image: targetAnime.main_picture?.large || targetAnime.main_picture?.medium || 'N/A'
      });
      
      watchlistIds.add(targetAnime.id);
      updateWatchlistCounter();
      
      if (showNotif) {
        showNotification(`Added "${targetAnime.title}" to watchlist!`, 'success');
      }
      
      console.log('üìù Added to watchlist:', targetAnime.title);
      console.log('üìä Total watchlist items:', watchlistAnime.length);
    }
    
    function updateWatchlistCounter() {
      const counterElement = document.getElementById('docs-count');
      counterElement.textContent = watchlistAnime.length;
      
      // Add pulse animation when counter updates
      counterElement.style.transform = 'scale(1.3)';
      counterElement.style.color = '#4ecdc4';
      setTimeout(() => {
        counterElement.style.transform = 'scale(1)';
        counterElement.style.color = 'white';
      }, 200);
      
      // Enable/disable download button based on watchlist content
      const downloadBtn = document.getElementById('download-docs-btn');
      if (watchlistAnime.length === 0) {
        downloadBtn.disabled = true;
        downloadBtn.style.opacity = '0.5';
      } else {
        downloadBtn.disabled = false;
        downloadBtn.style.opacity = '1';
      }
    }
    
    async function formatWatchlistWithGemini(animeList) {
      try {
        console.log('Formatting watchlist with Gemini...');
        
        // Prepare anime data for Gemini
        const animeData = animeList.map(anime => ({
          title: anime.title,
          synopsis: anime.synopsis,
          source: anime.source,
          addedDate: anime.addedDate
        }));
        
        const prompt = `Please format this anime watchlist into a beautiful, well-organized document. Make it professional and easy to read:

${JSON.stringify(animeData, null, 2)}

Format it as:
1. A nice header/title
2. A brief introduction 
3. Organized list of anime with descriptions
4. Maybe add some emojis and formatting to make it visually appealing
5. Include the date each anime was added
6. Add a footer with the total count

Make it ready for saving as a text document.`;

        const response = await fetch('/api/generate', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            contents: [{
              parts: [{
                text: prompt
              }]
            }]
          })
        });

        if (response.ok) {
          const data = await response.json();
          return data.candidates[0].content.parts[0].text;
        } else {
          console.warn('Gemini API failed, using fallback formatting');
          return formatWatchlistFallback(animeList);
        }
      } catch (error) {
        console.error('Error with Gemini formatting:', error);
        return formatWatchlistFallback(animeList);
      }
    }
    
    function formatWatchlistFallback(animeList) {
      let document = `üéå MY ANIME WATCHLIST üéå\n`;
      document += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n`;
      document += `üìÖ Generated on: ${new Date().toLocaleDateString()}\n`;
      document += `üìä Total Anime: ${animeList.length}\n\n`;
      
      if (animeList.length === 0) {
        document += `Your watchlist is empty! Start adding anime you're interested in.\n\n`;
      } else {
        document += `‚ú® RECOMMENDED FOR YOU ‚ú®\n\n`;
        
        animeList.forEach((anime, index) => {
          document += `${index + 1}. üì∫ ${anime.title}\n`;
          document += `   üìù ${anime.synopsis}\n`;
          document += `   üè∑Ô∏è  Source: ${anime.source === 'similar' ? 'Based on your likes' : 'Trending'}\n`;
          document += `   üìÖ Added: ${anime.addedDate}\n`;
          if (anime.image && anime.image !== 'N/A') {
            document += `   üñºÔ∏è  Image: ${anime.image}\n`;
          }
          document += `\n`;
        });
      }
      
      document += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`;
      document += `üåü Happy watching! Generated by Yomiru üåü\n`;
      document += `üîó Visit us at: ${window.location.origin}\n`;
      
      return document;
    }
    
    async function downloadWatchlist() {
      if (watchlistAnime.length === 0) {
        showNotification('Your watchlist is empty!', 'error');
        return;
      }
      
      try {
        showNotification('Generating your watchlist document...', 'success');
        
        // Try to format with Gemini, fallback to basic formatting
        const formattedDocument = await formatWatchlistWithGemini(watchlistAnime);
        
        // Create and download the file
        const blob = new Blob([formattedDocument], { type: 'text/plain' });
        const url = window.URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `Yomiru-Watchlist-${new Date().toISOString().split('T')[0]}.txt`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        window.URL.revokeObjectURL(url);
        
        showNotification(`Downloaded watchlist with ${watchlistAnime.length} anime!`, 'success');
        
      } catch (error) {
        console.error('Error downloading watchlist:', error);
        showNotification('Error creating download. Please try again.', 'error');
      }
    }
    
    // Event listeners
    document.getElementById('cross-btn').addEventListener('click', () => swipeCard('left'));
    document.getElementById('check-btn').addEventListener('click', () => swipeCard('right'));
    document.getElementById('download-docs-btn').addEventListener('click', downloadWatchlist);
    
    // Initialize watchlist counter
    updateWatchlistCounter();
    
    initializeRecommendations();
  </script>


<footer>
        <p class="copyright">¬© 2025 Yomiru. All rights reserved.</p>
    </footer>
</body>
