// ========== API Base URL ==========
// Sets base URL depending on environment (localhost vs production)
const API_BASE = window.location.hostname === 'localhost' 
  ? "http://localhost:3000" 
  : "https://final-project-10-streams.onrender.com";

// Tracemoe watchlist functionality
let tracemoeWatchlist = [];
let tracemoeWatchlistIds = new Set();

// ========== Show notification on screen ==========
/**
 * Shows a floating notification to the user
 * Input: message (string), type (success or error)
 * Output: A notification element shown briefly
 */
function showNotification(message, type = 'success') {
  const notification = document.createElement('div');
  notification.className = `notification ${type}`;
  notification.textContent = message;
  document.body.appendChild(notification);
  
  // Show notification
  setTimeout(() => notification.classList.add('show'), 100);
  
  // Hide notification after 3 seconds
  setTimeout(() => {
    notification.classList.remove('show');
    setTimeout(() => document.body.removeChild(notification), 300);
  }, 3000);
}

// ========== Add anime to TraceMoe watchlist ==========
/**
 * Adds an anime object to the watchlist if not already added
 * Input: anime (object)
 * Output: Updates the watchlist and shows a notification
 */
function addToTracemoeWatchlist(anime) {
  if (!anime) return;
  
  // Check if already in watchlist
  if (tracemoeWatchlistIds.has(anime.id)) {
    console.log(`${anime.title} is already in tracemoe watchlist`);
    return;
  }
  
  // Add to watchlist
  tracemoeWatchlist.push({
    id: anime.id,
    title: anime.title,
    synopsis: anime.synopsis || 'No synopsis available.',
    addedDate: new Date().toLocaleDateString(),
    episode: anime.episode,
    similarity: anime.similarity,
    malId: anime.malId
  });
  
  tracemoeWatchlistIds.add(anime.id);
  updateTracemoeCounter();
  
  showNotification(`Added "${anime.title}" to watchlist!`, 'success');
  
  console.log('üìù Added to tracemoe watchlist:', anime.title);
  console.log('üìä Total tracemoe watchlist items:', tracemoeWatchlist.length);
}

// ========== Update watchlist counter ==========
/**
 * Updates the watchlist counter element on the page
 * Also toggles download button state
 */
function updateTracemoeCounter() {
  const counterElement = document.getElementById('tracemoe-count');
  if (counterElement) {
    counterElement.textContent = tracemoeWatchlist.length;
    
    // Add pulse animation when counter updates
    counterElement.style.transform = 'scale(1.3)';
    counterElement.style.color = '#4ecdc4';
    setTimeout(() => {
      counterElement.style.transform = 'scale(1)';
      counterElement.style.color = 'white';
    }, 200);
    
    // Enable/disable download button based on watchlist content
    const downloadBtn = document.getElementById('download-tracemoe-watchlist-btn');
    if (downloadBtn) {
      if (tracemoeWatchlist.length === 0) {
        downloadBtn.disabled = true;
        downloadBtn.style.opacity = '0.5';
      } else {
        downloadBtn.disabled = false;
        downloadBtn.style.opacity = '1';
      }
    }
  }
}

// ========== Format watchlist for download ==========
/**
 * Converts anime list to a formatted plain text document
 * Input: animeList (array)
 * Output: String containing formatted watchlist
 */
function formatTracemoeWatchlist(animeList) {
  let document = `üîç TRACEMOE WATCHLIST üîç\n`;
  document += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n`;
  document += `üìÖ Generated on: ${new Date().toLocaleDateString()}\n`;
  document += `üìä Total Anime Found: ${animeList.length}\n\n`;
  
  if (animeList.length === 0) {
    document += `Your TraceMoe watchlist is empty! Upload screenshots to identify anime.\n\n`;
  } else {
    document += `üéØ ANIME IDENTIFIED FROM SCREENSHOTS üéØ\n\n`;
    
    animeList.forEach((anime, index) => {
      document += `${index + 1}. üì∫ ${anime.title}\n`;
      document += `   üìù ${anime.synopsis}\n`;
      if (anime.episode) {
        document += `   üìº Episode: ${anime.episode}\n`;
      }
      if (anime.similarity) {
        document += `   üéØ Similarity: ${(anime.similarity * 100).toFixed(1)}%\n`;
      }
      if (anime.malId) {
        document += `   üÜî MAL ID: ${anime.malId}\n`;
      }
      document += `   üìÖ Added: ${anime.addedDate}\n\n`;
    });
  }
  
  document += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`;
  document += `üåü Happy watching! Generated by Yomiru TraceMoe üåü\n`;
  document += `üîó Visit us at: ${window.location.origin}\n`;
  
  return document;
}

// ========== Download watchlist ==========
/**
 * Creates a .txt file of the watchlist and downloads it
 * Output: Triggers file download in browser
 */
async function downloadTracemoeWatchlist() {
  if (tracemoeWatchlist.length === 0) {
    showNotification('Your TraceMoe watchlist is empty!', 'error');
    return;
  }
  
  try {
    showNotification('Generating your TraceMoe watchlist document...', 'success');
    
    const formattedDocument = formatTracemoeWatchlist(tracemoeWatchlist);
    
    // Create and download the file
    const blob = new Blob([formattedDocument], { type: 'text/plain' });
    const url = window.URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `Yomiru-TraceMoe-Watchlist-${new Date().toISOString().split('T')[0]}.txt`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    window.URL.revokeObjectURL(url);
    
    showNotification(`Downloaded TraceMoe watchlist with ${tracemoeWatchlist.length} anime!`, 'success');
    
  } catch (error) {
    console.error('Error downloading tracemoe watchlist:', error);
    showNotification('Error creating download. Please try again.', 'error');
  }
}

// ========== Get anime info by title ==========
/**
 * Gets anime synopsis from title
 * Input: title (string)
 * Output: synopsis (string)
 */
async function getAnimeInfo(title) {
  const response = await fetch(`${API_BASE}/mal/anime-info?title=${encodeURIComponent(title)}`);

  const data = await response.json();
  const anime = data.data?.[0]?.node;

  if (!anime) {
    console.error("Anime not found");
    return;
  }

  return anime.synopsis;
}

// ========== Recommend anime ==========
/**
 * Fetches anime data by title and suggests related anime
 * Output: Displays info and recommendations on page
 */
async function getAnimeDetailsThenSuggest() {
  const title = document.getElementById('animeSuggest').value;

  const response = await fetch(`${API_BASE}/mal/recommend?title=${encodeURIComponent(title)}`);
  const data = await response.json();

  if (!data.anime) {
    document.getElementById("malResult2").innerText = "Anime not found.";
    return;
  }

  const anime = data.anime;
  const genreString = anime.genres.join(", ") || "N/A";

  document.getElementById("malResult2").innerHTML = `
    <h3>${anime.title}</h3>
    <p><strong>Genres:</strong> ${genreString}</p>
    <p><strong>Rating:</strong> ${anime.mean ?? "N/A"}</p>
    <p><strong>Popularity:</strong> ${anime.popularity ?? "N/A"}</p>
  `;

  if (data.recommendations?.length > 0) {
    document.getElementById("malSuggestions").innerHTML = `
      <h4>Recommended anime (based on genre: ${anime.genres[0]}):</h4>
      <ul>
        ${data.recommendations.map(a => `<li>${a.title} (Rating: ${a.mean})</li>`).join("")}
      </ul>
    `;
  } else {
    document.getElementById("malSuggestions").innerText = `No high-rated suggestions found for genre: ${anime.genres[0]}`;
  }
}

// ========== Clean title (remove brackets or file extensions) ==========
function cleanTitle(title) {
  // Remove bracketed and parenthesized content (e.g., [ReinForce], (BDRip))
  let cleanedTitle = title.replace(/\[.*?\]/g, "").replace(/\(.*?\)/g, "");
  // Remove common file extensions
  cleanedTitle = cleanedTitle.replace(/\.mp4|\.mkv|\.avi|\.flac/gi, "");
  // Trim whitespace from the start and end
  return cleanedTitle.trim();
}

// ========== Get anime info by MAL ID ==========
async function getAnimeInfoById(malId) {
  const response = await fetch(`${API_BASE}/mal/anime-by-id/${malId}`);
  const data = await response.json();
  return data.synopsis;
}

// ========== TraceMoe image search ==========
/**
 * Uses image from file input to identify anime using TraceMoe API
 * Output: Displays result + adds to watchlist
 */
async function testTraceMoe() {
  const fileInput = document.getElementById('tracemoein');
  const file = fileInput.files[0];

  if (!file) {
    return;
  }

  const formData = new FormData();
  formData.append("image", file);

  try {
    // Use backend endpoint to avoid CORS issues
    const endpoint = `${API_BASE}/tracemoe/search`;
    console.log('üîç TraceMoe endpoint:', endpoint);
    
    const traceRes = await fetch(endpoint, {
      method: "POST",
      body: formData,
    });

    if (!traceRes.ok) {
      throw new Error(`HTTP ${traceRes.status}: ${traceRes.statusText}`);
    }

    const traceData = await traceRes.json();
    console.log('üì° TraceMoe response:', traceData);
    const bestMatch = traceData.result?.[0];

    if (bestMatch) {
      const malId = bestMatch.anilist.idMal; // Use MAL ID from the response
      const title =
        bestMatch.anime ||
        bestMatch.title_english ||
        bestMatch.title_native ||
        bestMatch.filename ||
        "Unknown Title";

      const episode = bestMatch.episode;
      const similarity = bestMatch.similarity;
      const videoUrl = bestMatch.video;
      const from = bestMatch.from;

      const minutes = Math.floor(from / 60);
      const seconds = Math.floor(from % 60);

      // Fetch summary using the MAL ID if available, otherwise fall back to title search
      let summary;
      if (malId) {
        summary = await getAnimeInfoById(malId);
      } else {
        const cleanedTitle = cleanTitle(title);
        summary = await getAnimeInfo(cleanedTitle);
      }

      document.getElementById("tracemoeheading").innerHTML = `<strong>Title:</strong> ${title}<br>`;
      document.getElementById("tracemoepara").innerHTML =
        `<strong>Episode:</strong> ${episode}<br>` +
        `<strong>Timestamp:</strong> ${minutes}:${seconds.toString().padStart(2, '0')}<br>` +
        `<strong>Similarity:</strong> ${similarity.toFixed(2)}<br><br>` +
        `<video controls width="300" src="${videoUrl}"></video><br>` +
        `<strong>Summary:</strong> ${summary || "Summary not available."}`;
      
      // Automatically add detected anime to tracemoe watchlist
      const detectedAnime = {
        id: malId || title.replace(/\s+/g, '').toLowerCase(), // Use MAL ID or generate unique ID from title
        title: title,
        synopsis: summary,
        episode: episode,
        similarity: similarity,
        malId: malId
      };
      
      addToTracemoeWatchlist(detectedAnime);
    } else {
      console.log("TraceMoe full response:", traceData);
      document.getElementById("tracemoeheading").textContent = "No match found.";
      document.getElementById("tracemoepara").textContent = "";
    }
  } catch (err) {
    console.error("Trace Moe error:", err);
    document.getElementById("tracemoeheading").textContent = "Error calling Trace Moe.";
    document.getElementById("tracemoepara").textContent = "";
  }
}

// ========== Perform anime search ==========
/**
 * Searches for anime using input term
 * Input: searchTerm (string)
 * Output: Displays results or error
 */
async function performSearch(searchTerm) {
  if (!searchTerm) return;

  currentSearchTerm = searchTerm;
  showSearchResults();

  try {
    const res = await fetch(`${API_BASE}/mal/search?title=${encodeURIComponent(searchTerm)}`);
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();      // expect { data: [ { node: { ‚Ä¶ }}, ‚Ä¶ ] }
    displaySearchResults(data);
  } catch (err) {
    console.error("Search error:", err);
    displayNoResults(`Error fetching results.`);
  }
}

// ========== Setup event listeners on page load =========
document.addEventListener("DOMContentLoaded", () => {
  const animeSuggestButton = document.getElementById("animeSuggestButton");
  if (animeSuggestButton) {
    animeSuggestButton.addEventListener("click", getAnimeDetailsThenSuggest);
  }
  
  const tracemoein = document.getElementById("tracemoein");
  if (tracemoein) {
    tracemoein.addEventListener("change", testTraceMoe);
  }

  // ‚Äî Search bar (only on Enter)
  const searchInput = document.getElementById("search-input");
  const clearBtn = document.querySelector(".clear-btn");
  if (searchInput) {
    // focus when page loads
    searchInput.focus();

    // trigger search on Enter
    searchInput.addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
        const query = searchInput.value.trim();
        if (query) {
          performSearch(query);
        }
      }
    });
  }

  // ‚Äî Clear button for search
  if (clearBtn) {
    clearBtn.addEventListener("click", () => {
      searchInput.value = "";
      clearBtn.style.display = "none";
      showTrending();      // restores your trending grid
      document.getElementById("search-results").innerHTML = "";
      searchInput.focus();
    });
  }

  // ‚Äî TraceMoe download watchlist button
  const downloadTracemoeBtn = document.getElementById("download-tracemoe-watchlist-btn");
  if (downloadTracemoeBtn) {
    downloadTracemoeBtn.addEventListener("click", downloadTracemoeWatchlist);
    // Initialize counter and button state
    updateTracemoeCounter();
  }
});